{"meta":{"title":"前端博客","subtitle":"前端分享","description":"学习总结 思考感悟","author":"chenghao","url":"https://yezihaohao.github.io"},"pages":[{"title":"Hello World","date":"un55fin55","updated":"un44fin44","path":"hello-world.html","permalink":"https://yezihaohao.github.io/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"categories","date":"un44fin44","updated":"un44fin44","path":"categories/index.html","permalink":"https://yezihaohao.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"un44fin44","updated":"un44fin44","path":"about/index.html","permalink":"https://yezihaohao.github.io/about/index.html","excerpt":"","text":"关于测试呵呵我只是想安静地写前端"},{"title":"tags","date":"un44fin44","updated":"un44fin44","path":"tags/index.html","permalink":"https://yezihaohao.github.io/tags/index.html","excerpt":"","text":""},{"title":"imgs","date":"un66fin66","updated":"un66fin66","path":"imgs/index.html","permalink":"https://yezihaohao.github.io/imgs/index.html","excerpt":"","text":""}],"posts":[{"title":"H5手机端开发问题汇总及解决方案","slug":"H5手机端开发问题汇总及解决方案","date":"un55fin55","updated":"un55fin55","path":"2018/03/30/H5手机端开发问题汇总及解决方案/","link":"","permalink":"https://yezihaohao.github.io/2018/03/30/H5手机端开发问题汇总及解决方案/","excerpt":"","text":"前言 少侠，请留步，相见必是缘分，赠与你一部《踏坑秘籍》 扎马步踏坑第一式ios竖屏拍照上传，图片被旋转问题 解决方案12345678// 几个步骤// 1.通过第三方插件exif-js获取到图片的方向// 2.new一个FileReader对象，加载读取上传的图片// 3.在fileReader的onload函数中，得到的图片文件用一个Image对象接收// 4.在image的onload函数中，利用步骤1中获取到的方向orientation，通过canvas旋转校正，重新绘制一张新图// 注意iPhone有3个拍照方向需要处理，横屏拍摄，home键在左侧，竖屏拍摄，home建上下// 5.将绘制的新图转成Blob对象，添加到FormData对象中，然后进行校正后的上传操作// 代码有点杂，待整理后上传，网上应该是可以找到的 踏坑第二式ios：DOM元素固定一边，另一边滚动，滚动很卡的问题12// (横向滚动用的多些)简单粗暴的办法，样式添加如下属性-webkit-overflow-scrolling: touch; 踏坑第三式部分手机第三方输入法会将页面网上挤的问题123456// 特定需求页面，比如评论页面，输入框在顶部之类的const interval = setInterval(function() &#123; document.body.scrollTop = 0;&#125;, 100)// 注意关闭页面或者销毁组件的时候记得清空定时器clearInterval(interval); 踏坑第四式iPhoneX适配12345678910111213// 1.viewport meta 标签增加属性viewport-fit=cover&lt;meta name=\"viewport\" content=\"width=device-width, viewport-fit=cover, xxxx\"&gt;// 2.body元素增加样式body &#123; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom);&#125;// 3.如有fixed底部的元素，也增加上面样式xxx &#123; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom); background-color: #fff; // 记得添加background-color，不然会出现透明镂空的情况&#125; 踏坑第五式某些机型不支持video标签的poster属性，特别是安卓123用图片元素 &lt;img /&gt;来代替poster播放前显示&lt;img /&gt;，隐藏 &lt;video /&gt;播放后显示&lt;video /&gt;，隐藏 &lt;img /&gt; 踏坑第六式CSS透明度颜色设置问题12Android部分不支持 hex写法，推荐用rgba的写法#0000009c --&gt; rgba(0, 0, 0, 0.61) 踏坑第七式flex对低版本的ios和Android的支持问题12345678使用postcss的autoprefixer插件，自动添加浏览器内核前缀，并且增加更低浏览器版本的配置，自动添加flex老版本的属性和写法autoprefixer(&#123; browsers: [ 'iOS &gt;= 6', // 特殊处理支持低版本IOS 'Safari &gt;= 6', // 特殊处理支持低版本Safari ],&#125;), 踏坑第八式ios 页面回退到长列表出现灰色遮挡问题 123456方案1：对列表数据进行缓存，比如redux之类的用法。方案2：回退时，跳到页面顶部。const timer = setTimeout(() =&gt; &#123; window.scrollTo(0, 1); window.scrollTo(0, 0);&#125;, 0); 踏坑第九式ios 日期转换NAN的问题12将日期字符串的格式符号替换成'/'。栗子：'yyyy-MM-dd'.replace(/-/g, '/') 踏坑第十式（React）未知错误异常，导致页面崩溃，空白12React 16.x 增加了componentDidCatch() 生命周期方法捕获全局异常来进行页面的友好提示（具体用法网上有很多资料） 打完收招晋级还需要多多修炼 前端攻城狮②群：592688854。欢迎感兴趣的各路武林豪杰加入。","categories":[],"tags":[{"name":"H5","slug":"H5","permalink":"https://yezihaohao.github.io/tags/H5/"}]},{"title":"腾讯地图React组件,附demo和源码","slug":"腾讯地图React组件-附demo和源码","date":"un00fin00","updated":"un00fin00","path":"2018/03/11/腾讯地图React组件-附demo和源码/","link":"","permalink":"https://yezihaohao.github.io/2018/03/11/腾讯地图React组件-附demo和源码/","excerpt":"一个对腾讯web地图简单封装的React组件GitHub源码地址：戳我 栗子：戳我 栗子源码：戳我 安装123yarn add react-qmap or npm install react-qmap","text":"一个对腾讯web地图简单封装的React组件GitHub源码地址：戳我 栗子：戳我 栗子源码：戳我 安装123yarn add react-qmap or npm install react-qmap 基础用法12345678import ReactQMap from 'react-qmap';&lt;ReactQMap center=&#123;&#123;latitude: 30.53786, longitude: 104.07265&#125;&#125; initialOptions=&#123;&#123;zoomControl: true, mapTypeControl: true&#125;&#125; apiKey=\"xxxxxx-xxxxx-xxxxx-xxxxxx\" style=&#123;&#123;height: 300&#125;&#125; // 高度和宽度默认占父元素的100%/&gt; API Method Type Optional Default Description getMap function false 获取地图的对象和当前容器的map对象,第一个参数是new的当前map对象，第二个参数是全局map对象 style object false 设置组件的内联样式，默认样式width: ‘100%’, height: ‘100%’ className string false 设置组件的class mySpot object false 设置地图的定位坐标 initialOptions object false zoom: 14,disableDefaultUI: true, zoomControl: false,mapTypeControl: false, 初始化地图的参数，简单默认设置了几个，更多的初始化参数请参照文档 apiKey string true 设置地图引用的key,为防止限制调用API,建议官网申请自己的key center object true 设置地图初始化的中心位置坐标 关于有了初始化的地图，获取到地图对象之后，就可以按照官网提供的资料随心所欲了。 更多关于API的操作请查看腾讯地图官网（戳我） 简单的封装了一块原石，封装还在继续，如果老铁有更好的方式或想法不妨PR走起一波~会给你双击666 如果有问题可加入前端交流群一起讨论：前端攻城狮②群：592688854 licenseMIT","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://yezihaohao.github.io/tags/react/"},{"name":"map","slug":"map","permalink":"https://yezihaohao.github.io/tags/map/"}]},{"title":"ReactNative模仿网易云音乐手机客户端，兼容安卓和IOS两个平台","slug":"ReactNative模仿网易云音乐手机客户端，兼容安卓和IOS两个平台","date":"un11fin11","updated":"un55fin55","path":"2017/10/23/ReactNative模仿网易云音乐手机客户端，兼容安卓和IOS两个平台/","link":"","permalink":"https://yezihaohao.github.io/2017/10/23/ReactNative模仿网易云音乐手机客户端，兼容安卓和IOS两个平台/","excerpt":"React Native 模仿网易云音乐手机客户端，兼容安卓和IOS两个平台。 GitHub 完整源码地址https://github.com/yezihaohao/NeteaseCloudMusic 老规矩，先上图~😄 总览 音乐播放","text":"React Native 模仿网易云音乐手机客户端，兼容安卓和IOS两个平台。 GitHub 完整源码地址https://github.com/yezihaohao/NeteaseCloudMusic 老规矩，先上图~😄 总览 音乐播放 视频播放 歌曲列表 用户界面 电台详情 主要的技术栈和依赖第三方库：点击名称可跳转相关项目网站😄😄 react@16.0.0-alpha.12 react-native@0.48.2 react-native-scrollable-tab-view@0.7.4(可滚动切换tab页面组件) react-native-swiper@1.5.10 react-native-vector-icons@4.3.0(包含很多icon图标) react-native-video@2.0.0(视频和音频播放器，经调研，最近版的安卓和IOS系统版本可正常使用) react-navigation@1.0.0-beta.11(推荐使用的路由库) redux@3.7.2(项目中重点用在播放器相关功能上) 其他细节库省略 ps: 个别插件会存在小bug或冲突。比如安卓平台swiper在scrollable-tab中不能触屏手动滚动。 主要的功能界面模块 大部分主要是展示的demo，网易云的页面和功能实在是太多了，由于时间关系，并没有把所有的功能都做完整，后续会陆续加上其他的功能。 各部分模块首页展示 音乐播放，包括CD动画，歌词同步等。 MV视频播放 个人详情页面 其他细节等等 安装运行 特别鸣谢：NeteaseCloudMusicApi 提供全套API。 运行本项目前请先本地（或服务器）运行此API接口项目,替换/scr/api/index.js 下BASE_URL的ip地址 1234567890. 开发环境平台版本：Android-6.0 ios-10.31. git clone https://github.com/yezihaohao/NeteaseCloudMusic.git2. yarn or npm install3. react-native link 3. react-native run-ios 或者 react-native run-android 总结react-native上手不难，熟悉react，看react-native文档，看下开源项目就可以开始开发，就是向下兼容比较差，可能这个版本用的别人的组件下个版本就会有bug。 一般展示性的界面比较容易，重点熟悉flex布局，注意默认纵向排列。 动画模块也需要着重了解下，可以提升用户体验。 多了解下其他的第三方组件，有很多别人都写好的，也要看react-native更新文档。 其他细节在开发过程中慢慢体会~~😄😄😄 刚入门react-native，大佬轻喷~~ 该项目会持续更新~所有使用数据仅供学习交流，并无它意。若有疑问，可加前端QQ群与我交流：264591039","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://yezihaohao.github.io/tags/React/"},{"name":"ReactNative","slug":"ReactNative","permalink":"https://yezihaohao.github.io/tags/ReactNative/"}]},{"title":"Jenkins实现前端项目自动化集成打包部署","slug":"Jenkins实现前端项目自动化集成打包部署","date":"un66fin66","updated":"un11fin11","path":"2017/09/09/Jenkins实现前端项目自动化集成打包部署/","link":"","permalink":"https://yezihaohao.github.io/2017/09/09/Jenkins实现前端项目自动化集成打包部署/","excerpt":"前言 以前写前端项目打包部署，都是手动运行命令，打包完，然后压缩，再上传到服务器解压。 这种方式确实有点low并且效率也不高。 自从用了Jenkins持续集成工具，写前端项目越来越工程化，再也不用担心忘记部署项目，也不用烦躁每次打包压缩后还要部署多个服务器和环境，更开心的是每次家里写完代码，不用远程公司部署项目，提交代码后自动会为你部署。 本文基于React的前端项目和GitLab的代码仓库以及Windows(其他系统平台大同小异)，简述Jenkins实现自动部署的配置。 安装Jenkins前提：已配置好java环境 1.下载对应的安装程序点我进入下载网站或直接下载war包 2.根据提示安装完成（默认端口是8080）war包启动方式： java -jar jenkins.war –httpPort=8080（端口自定义），然后访问http://localhost:8080 3.查看插件点开系统设置的插件管理页面，如果可选插件列表为空，点击高级标签页，替换升级站点的URL为：http://mirror.xmission.com/jenkins/updates/update-center.json并且点击提交和立即获取 4.返回可选插件，选择如下插件安装（如果已安装，请忽略）1.Publish Over SSH2.GitLab Plugin3.Email Extension Plugin","text":"前言 以前写前端项目打包部署，都是手动运行命令，打包完，然后压缩，再上传到服务器解压。 这种方式确实有点low并且效率也不高。 自从用了Jenkins持续集成工具，写前端项目越来越工程化，再也不用担心忘记部署项目，也不用烦躁每次打包压缩后还要部署多个服务器和环境，更开心的是每次家里写完代码，不用远程公司部署项目，提交代码后自动会为你部署。 本文基于React的前端项目和GitLab的代码仓库以及Windows(其他系统平台大同小异)，简述Jenkins实现自动部署的配置。 安装Jenkins前提：已配置好java环境 1.下载对应的安装程序点我进入下载网站或直接下载war包 2.根据提示安装完成（默认端口是8080）war包启动方式： java -jar jenkins.war –httpPort=8080（端口自定义），然后访问http://localhost:8080 3.查看插件点开系统设置的插件管理页面，如果可选插件列表为空，点击高级标签页，替换升级站点的URL为：http://mirror.xmission.com/jenkins/updates/update-center.json并且点击提交和立即获取 4.返回可选插件，选择如下插件安装（如果已安装，请忽略）1.Publish Over SSH2.GitLab Plugin3.Email Extension Plugin 提前设置配置为了方便新建任务，所以先将一些设置配置好，进入系统管理系统设置。 1.配置Publish over SSH在Publish over SSH处点击增加，添加SSH server，并且选择高级设置，设置相应的ip,用户名和密码等。（其他选项可不用管） 2.配置邮件通知，可通过勾选发送邮件测试是否配置成功 新建任务1.点击新建，输入名称，选择自由风格的项目 2.配置源码选择Git，并填上gitlab项目克隆地址，用户密钥以及分支 3.配置构建触发器勾选Poll SCM即可，其他可忽略，默认提交代码到相应的分支触发该任务 4.配置构建增加构建步骤选择Execute shell 5.配置构建后操作增加构建后操作，选择Send build artifacts over SSH。即上述操作全部完成并自动生产了部署文件，该步骤将部署文件上传到之前的SSH服务器（Linux服务器），并执行你想让他执行的命名，部署多个服务器及平台，选择添加server并完成相应的配置配置后再增加构建后操作，选择Editable Email Notification。根据提示配置需要通知的邮箱，其他可默认。然后选择高级设置，配置失败和成功邮件通知。 绑定GitLab Web hooks添加web hook. http://jenkins-server/gitlab/notify_commit 需要填上的固定格式的URL地址，把jenkins-server替换成对应的Jenkins访问地址，注意：如果是localhost，需要换成ip地址。添加完之后，点击Test Hook。此时Jenkins界面构建队列出现某个任务正在执行，表示配置成功。 验证提交代码，成功自动打包部署提交代码，观察Jenkins界面，出现构建任务，构建完成之后收到邮件通知。 最后，推荐给大家前端交流QQ群：264591039。欢迎来这里和大家一起畅聊大前端的一切~","categories":[],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://yezihaohao.github.io/tags/前端工程化/"}]},{"title":"React+AntD后台管理系统解决方案--终极版","slug":"React-AntD后台管理系统解决方案-终极版","date":"un22fin22","updated":"un66fin66","path":"2017/05/09/React-AntD后台管理系统解决方案-终极版/","link":"","permalink":"https://yezihaohao.github.io/2017/05/09/React-AntD后台管理系统解决方案-终极版/","excerpt":"最下方增加版本更新日志😁前言 网上react后台管理开源免费的完整版项目比较少，所以利用空余时间集成了一个版本出来，已放到GitHub 启动和打包的时间都稍长，请耐心等待两分钟 GitHub地址 预览地址(已增加响应式，可手机预览😄) 依赖模块项目是用create-react-app创建的，主要还是列出新加的功能依赖包 点击名称可跳转相关网站😄😄 react@15.5.0 react-router@3.0.2(react路由,4.x的差异还是比较大，暂时还是3.x的版本) antd@2.9.3(蚂蚁金服开源的react ui组件框架) axios@0.16.1(http请求模块，可用于前端任何场景，很强大👍) echarts-for-react@1.2.0(可视化图表，别人基于react对echarts的封装，足够用了) recharts@0.22.3(另一个基于react封装的图表，个人觉得是没有echarts好用) nprogress@0.2.0(顶部加载条，蛮好用👍) react-draft-wysiwyg@1.9.6(别人基于react的富文本封装，如果找到其他更好的可以替换) react-draggable@2.2.4(拖拽模块，找了个简单版的) screenfull@3.2.0(全屏插件) photoswipe@4.1.2(图片弹层查看插件，不依赖jQuery，还是蛮好用👍) animate.css@3.5.1(css动画库) 其他小细节省略 功能模块备注：项目只引入了ant-design的部分组件，其他的组件antd官网有源码，可以直接复制到项目中使用，后续有时间补上全部组件。项目使用了antd的自定义主题功能–&gt;黑色，若想替换其他颜色，具体操作请查看antd官网","text":"最下方增加版本更新日志😁前言 网上react后台管理开源免费的完整版项目比较少，所以利用空余时间集成了一个版本出来，已放到GitHub 启动和打包的时间都稍长，请耐心等待两分钟 GitHub地址 预览地址(已增加响应式，可手机预览😄) 依赖模块项目是用create-react-app创建的，主要还是列出新加的功能依赖包 点击名称可跳转相关网站😄😄 react@15.5.0 react-router@3.0.2(react路由,4.x的差异还是比较大，暂时还是3.x的版本) antd@2.9.3(蚂蚁金服开源的react ui组件框架) axios@0.16.1(http请求模块，可用于前端任何场景，很强大👍) echarts-for-react@1.2.0(可视化图表，别人基于react对echarts的封装，足够用了) recharts@0.22.3(另一个基于react封装的图表，个人觉得是没有echarts好用) nprogress@0.2.0(顶部加载条，蛮好用👍) react-draft-wysiwyg@1.9.6(别人基于react的富文本封装，如果找到其他更好的可以替换) react-draggable@2.2.4(拖拽模块，找了个简单版的) screenfull@3.2.0(全屏插件) photoswipe@4.1.2(图片弹层查看插件，不依赖jQuery，还是蛮好用👍) animate.css@3.5.1(css动画库) 其他小细节省略 功能模块备注：项目只引入了ant-design的部分组件，其他的组件antd官网有源码，可以直接复制到项目中使用，后续有时间补上全部组件。项目使用了antd的自定义主题功能–&gt;黑色，若想替换其他颜色，具体操作请查看antd官网 首页 完整布局 换肤(全局功能，暂时只实现了顶部导航的换肤，后续加上其他模块) 导航菜单 顶部导航(菜单伸缩，全屏功能) 左边菜单(增加滚动条以及适配路由的active操作) UI模块 按钮(antd组件) 图标(antd组件并增加彩色表情符) 加载中(antd组件并增加顶部加载条) 通知提醒框(antd组件) 标签页(antd组件) 轮播图(ant动效组件) 富文本 拖拽 画廊 动画 基础动画(animate.css所有动画) 动画案例 表格 基础表格(antd组件) 高级表格(antd组件) 异步表格(数据来自掘金酱的接口) 表单 基础表单(antd组件) 图表 echarts图表 recharts图表 页面 登录页面(包括GitHub第三方登录) 404页面 功能截图首页 按钮图标等 轮播图 富文本 拖拽 画廊 动画 表格 表单 图表 页面 代码目录123456789101112131415161718192021222324252627282930313233343536+-- build/ ---打包的文件目录+-- config/ ---npm run eject 后的配置文件目录+-- node_modules/ ---npm下载文件目录+-- public/| --- index.html ---首页入口html文件| --- npm.json ---echarts测试数据| --- weibo.json ---echarts测试数据+-- src/ ---核心代码目录| +-- axios ---http请求存放目录| | --- index.js| +-- components ---各式各样的组件存放目录| | +-- animation ---动画组件| | | --- ...| | +-- charts ---图表组件| | | --- ...| | +-- dashboard ---首页组件| | | --- ...| | +-- forms ---表单组件| | | --- ...| | +-- pages ---页面组件| | | --- ...| | +-- tables ---表格组件| | | --- ...| | +-- ui ---ui组件| | | --- ...| | --- BreadcrumbCustom.jsx ---面包屑组件| | --- HeaderCustom.jsx ---顶部导航组件| | --- Page.jsx ---页面容器| | --- SiderCustom.jsx ---左边菜单组件| +-- style ---项目的样式存放目录，主要采用less编写| +-- utils ---工具文件存放目录| --- App.js ---组件入口文件| --- index.js ---项目的整体js入口文件，包括路由配置等--- .env ---启动项目自定义端口配置文件--- .eslintrc ---自定义eslint配置文件，包括增加的react jsx语法限制--- package.json 安装运行1.下载或克隆项目源码2.npm安装相关包文件(国内建议增加淘宝镜像源，不然很慢，你懂的😁)1npm i 3.启动项目1npm start 4.打包项目1npm run build 更新日志2017-07-08 依赖包版本升级 react@15.6.1 antd@2.11.2 webpack@2.6.1 等等2017-08-01 引入redux系列 redux@3.7.2 redux-thunk@2.2.0 react-redux@5.0.5 增加权限管理模块 使用easy-mock模拟数据模拟登录接口 使用redux系列将登录用户数据传递给权限组件 权限组件采用Render Callback的方式传递权限给需要受控制的组件（具体做法请查看源代码。） 用户状态保存在localStorage中 具体做法请运行项目查看 PS：以上管理权限只是一种方式，但这绝对不是唯一的方式，也不是最好的方式。如果你有更好的方式，不妨加上面的群和大家一起分享下。😄😄 增加路径别名 使用@别名处理引入组件相对路径过长问题。 缺点：编辑器不能使用快捷提示和快捷跳转到相应的文件2017-08-13 权限管理模块增加页面跳转权限验证 点击权限管理的路由拦截，若没有访问权限则会跳转到404页面。 大致实现方式(非常简单)：通过向自定义router组件传入store，登录之后可获取到redux中的权限state数据，并通过判断是否包含权限进行跳转。ps: 该demo的效果是管理员登录之后才能跳转到路由拦截页面。具体操作请拉取代码尝试。2017-08-26 增加响应式布局 替换antd Col 组件的响应式栅格为md(具体参数用法请查看antd官方文档) 初始化页面是获取当前浏览器宽度设置菜单显示类型 监听window的onresize函数，设置菜单显示类型。PS：浏览器宽度存入redux中，方便组件之间传递。 结尾该项目会不定时更新，后续时间会添加更多的模块 若有问题，可加QQ群264591039与我交流 如果对你有帮助，给个star哟~~❤️❤️❤️❤️","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://yezihaohao.github.io/tags/React/"}]},{"title":"React项目笔记之create-react-app自定义ESLint配置文件","slug":"React项目笔记-create-react-app自定义ESLint配置文件","date":"un00fin00","updated":"un11fin11","path":"2017/03/26/React项目笔记-create-react-app自定义ESLint配置文件/","link":"","permalink":"https://yezihaohao.github.io/2017/03/26/React项目笔记-create-react-app自定义ESLint配置文件/","excerpt":"前言 了解eslint基础用法，若想更进一步了解其，请查阅官网以及相关资料(中文网) 若有问题请指出或加群264591039与我讨论。 初始化项目使用create-react-app 创建项目（此过程不做详解），然后运行npm run eject使其暴露webpack等配置文件 自定义eslint上述步骤并没有暴露react脚手架封装的eslint操作，为了使得项目统一规范化，添加jsx-eslint操作是非常不错的选择（关于js其他的eslint操作，请参见官网，本文主要针对jsx限制规范配置）。 在项目根目录下添加.eslintrc文件","text":"前言 了解eslint基础用法，若想更进一步了解其，请查阅官网以及相关资料(中文网) 若有问题请指出或加群264591039与我讨论。 初始化项目使用create-react-app 创建项目（此过程不做详解），然后运行npm run eject使其暴露webpack等配置文件 自定义eslint上述步骤并没有暴露react脚手架封装的eslint操作，为了使得项目统一规范化，添加jsx-eslint操作是非常不错的选择（关于js其他的eslint操作，请参见官网，本文主要针对jsx限制规范配置）。 在项目根目录下添加.eslintrc文件 在根目录找到config文件夹，并找到文件夹下的webpack.config.dev.js文件 webpack.config.dev.js文件添加如下代码：1234567891011enforce: 'pre',use: [&#123; // @remove-on-eject-begin // Point ESLint to our predefined config. options: &#123; //configFile: path.join(__dirname, '../.eslintrc'), useEslintrc: true &#125;, // @remove-on-eject-end loader: 'eslint-loader'&#125;], 运行npm start,此时，你编写的jsx文件都是经过.eslintrc的配置限制 .eslintrc文件基本规范配置ps: 配置的value对应的值： 0 : off 1 : warning 2 : error不满足以下的规范设置的，编译代码时将有黄色提示具体配置规则可参见Github123456789101112131415&#123; \"extends\": \"react-app\", \"rules\": &#123; \"no-multi-spaces\": 1, \"react/jsx-space-before-closing\": 1, // 总是在自动关闭的标签前加一个空格，正常情况下也不需要换行 \"jsx-quotes\": 1, \"react/jsx-closing-bracket-location\": 1, // 遵循JSX语法缩进/格式 \"react/jsx-boolean-value\": 1, // 如果属性值为 true, 可以直接省略 \"react/no-string-refs\": 1, // 总是在Refs里使用回调函数 \"react/self-closing-comp\": 1, // 对于没有子元素的标签来说总是自己关闭标签 \"react/jsx-no-bind\": 1, // 当在 render() 里使用事件处理方法时，提前在构造函数里把 this 绑定上去 \"react/sort-comp\": 1, // 按照具体规范的React.createClass 的生命周期函数书写代码 \"react/jsx-pascal-case\": 1 // React模块名使用帕斯卡命名，实例使用骆驼式命名 &#125;&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://yezihaohao.github.io/tags/react/"},{"name":"eslint","slug":"eslint","permalink":"https://yezihaohao.github.io/tags/eslint/"}]},{"title":"Javascript项目笔记","slug":"Javascript项目笔记","date":"un11fin11","updated":"un33fin33","path":"2017/03/13/Javascript项目笔记/","link":"","permalink":"https://yezihaohao.github.io/2017/03/13/Javascript项目笔记/","excerpt":"针对项目中常用的javascript api等，进行一个汇总~文档持续更新中。。。 前提：有些功能可能浏览器还不支持，需要用babel进行转换，具体的babel环境搭建，请自行Baidu或google。 很多框架的脚手架生成的helloworld项目是已经搭好的环境，比如react或者vue，所以使用脚手架的童鞋大可放心使用。 若有问题可加群264591039与我讨论。 扩展运算符：三个点 …合并数组1234let arr1 = [1, 2], arr2 = [3, 4];arr1.push(...arr2); // 把arr2合并到arr1的尾部, arr1改变arr1.unshift(...arr2); // 把arr2合并到arr1的顶部, arr1改变[...arr1, ...arr2]; // 生成一个由arr1和arr2组成的新数组，原数组不变 复制对象","text":"针对项目中常用的javascript api等，进行一个汇总~文档持续更新中。。。 前提：有些功能可能浏览器还不支持，需要用babel进行转换，具体的babel环境搭建，请自行Baidu或google。 很多框架的脚手架生成的helloworld项目是已经搭好的环境，比如react或者vue，所以使用脚手架的童鞋大可放心使用。 若有问题可加群264591039与我讨论。 扩展运算符：三个点 …合并数组1234let arr1 = [1, 2], arr2 = [3, 4];arr1.push(...arr2); // 把arr2合并到arr1的尾部, arr1改变arr1.unshift(...arr2); // 把arr2合并到arr1的顶部, arr1改变[...arr1, ...arr2]; // 生成一个由arr1和arr2组成的新数组，原数组不变 复制对象 1234567let obj = &#123;a: 1&#125;;&#123;...obj, b: 2&#125;; // 返回一个新的对象，&#123;a: 1, b: 2&#125;, obj对象不变// 等价于下面的用法Object.assign(&#123;&#125;, obj, &#123;b: 2&#125;); // 返回一个新的对象，&#123;a: 1, b: 2&#125;, obj对象不变// 另外Object.assign 还有一个用法Object.assign(obj, &#123;b: 2&#125;); // 返回obj对象并且新增加了b属性：&#123;a: 1, b: 2&#125; obj对象改变// 由于使用的chrome浏览器还不支持第一种用法，只能演示Object.assign。项目中使用babel转换","categories":[],"tags":[]},{"title":"Socket.io+Notification实现浏览器消息推送","slug":"Socket-io-Notification实现浏览器消息推送","date":"un11fin11","updated":"un22fin22","path":"2017/02/20/Socket-io-Notification实现浏览器消息推送/","link":"","permalink":"https://yezihaohao.github.io/2017/02/20/Socket-io-Notification实现浏览器消息推送/","excerpt":"前言 socket.io: 包含对websocket的封装，可实现服务端和客户端之前的通信。详情见官网 (虽然是英文文档，但还是通俗易懂)。 Notification: Html5新特性，用于浏览器的桌面通知，只有部分浏览器支持。 通过nodejs+Socket.io+Notification实现服务端往浏览器客户端发送自定义消息。 若有问题可加群264591039与我讨论。 转载请注明出处！ 开发前提本地安装nodejs以及npm对nodejs以及express框架有一定了解。（本篇将和官方文档一样，采用express 4.10.2） 环境搭建 新建一个文件夹notification（以下操作都在该文件夹的根目录进行） npm初始化package.json文件 npm init 安装express(指定版本4.10.2，没有试过其他版本，感兴趣可以试下) npm install --save express@4.10.2 安装socket.io(本人安装的版本是1.7.3) npm install --save socket.io 编写代码构建通信环境在根目录下新建一个index.html（注：index页面的样式来自socket.io的官方示例）12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Socket.IO Notification&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; font: 13px Helvetica, Arial; &#125; form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125; form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125; form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125; #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125; #messages li &#123; padding: 5px 10px; &#125; #messages li:nth-child(odd) &#123; background: #eee; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;messages&quot;&gt;&lt;/ul&gt; &lt;form action=&quot;&quot;&gt; &lt;input id=&quot;m&quot; autocomplete=&quot;off&quot; /&gt;&lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 新建一个index.js文件，并在js文件中构建相应的对象和变量，创建监听端口为8080 的服务器，以及添加映射到index.html的路由。","text":"前言 socket.io: 包含对websocket的封装，可实现服务端和客户端之前的通信。详情见官网 (虽然是英文文档，但还是通俗易懂)。 Notification: Html5新特性，用于浏览器的桌面通知，只有部分浏览器支持。 通过nodejs+Socket.io+Notification实现服务端往浏览器客户端发送自定义消息。 若有问题可加群264591039与我讨论。 转载请注明出处！ 开发前提本地安装nodejs以及npm对nodejs以及express框架有一定了解。（本篇将和官方文档一样，采用express 4.10.2） 环境搭建 新建一个文件夹notification（以下操作都在该文件夹的根目录进行） npm初始化package.json文件 npm init 安装express(指定版本4.10.2，没有试过其他版本，感兴趣可以试下) npm install --save express@4.10.2 安装socket.io(本人安装的版本是1.7.3) npm install --save socket.io 编写代码构建通信环境在根目录下新建一个index.html（注：index页面的样式来自socket.io的官方示例）12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Socket.IO Notification&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; font: 13px Helvetica, Arial; &#125; form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125; form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125; form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125; #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125; #messages li &#123; padding: 5px 10px; &#125; #messages li:nth-child(odd) &#123; background: #eee; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;messages&quot;&gt;&lt;/ul&gt; &lt;form action=&quot;&quot;&gt; &lt;input id=&quot;m&quot; autocomplete=&quot;off&quot; /&gt;&lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 新建一个index.js文件，并在js文件中构建相应的对象和变量，创建监听端口为8080 的服务器，以及添加映射到index.html的路由。12345678910111213let express = require('express'), app = express(), http = require('http').Server(app), io = require('socket.io')(http);app.use(express.static(__dirname + '/public'));app.get('/', function(req, res)&#123; res.sendfile('index.html');&#125;);http.listen(8080, function()&#123; console.log('listening on port 8080');&#125;); 运行 node index.js 用浏览器打开http://localhost:8080 成功的话即可看到index.html页面的内容。在index.js的监听端口代码上方添加socket.io的监听事件，监听用户连接的connection。123io.on('connection', function(socket)&#123; console.log('a user connected');&#125;); 创建监听Event事件:notification，并用emit向客户端推送消息1234567io.on('connection', function(socket)&#123; console.log('a user connected'); socket.on('notification', function(msg)&#123; console.log(msg); io.emit('notification', msg); &#125;);&#125;); 在index.html页面中的上方引入socket.io文件，并用emit向服务器提交数据以及监听事件notification，接收服务器推送的消息注意，引入socket.io的方式在运行node index.js之后才有效果，直接打开index.html是找不到这个文件的12345678910111213 &lt;script type=\"text/javascript\" src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"http://code.jquery.com/jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script&gt;let socket = io();$('form').submit(function()&#123; socket.emit('notification', $('#m').val()); $('#m').val(''); return false;&#125;);socket.on('notification', function(msg)&#123; console.log(msg);&#125;); &lt;/script&gt; 浏览器打开http://localhost:8080 后，在input框中输入，点击发送，在nodejs运行的控制台可以看到如下信息：1234a user connected //以下数据是输入框输入的数据hello test测试 实现自定义消息推送完整代码：12345678910111213141516171819202122232425 &lt;script&gt;let socket = io();$('form').submit(function()&#123; socket.emit('notification', $('#m').val()); $('#m').val(''); return false;&#125;);socket.on('notification', function(msg)&#123; notice(msg); //若允许通知，待输入消息后监听变化就会调用通知方法&#125;); Notification.requestPermission(function(permission) &#123;&#125;); //询问浏览器是否允许通知 function notice(msg) &#123; let _notification = new Notification(`消息通知`,&#123; body:`$&#123;msg&#125;`, icon:'http://localhost:8080/23539868.jpg' &#125;); setTimeout(function()&#123; _notification.close(); //设置5秒后自动关闭通知框 &#125;,5000); &#125; &lt;/script&gt; 运行截图完整示例代码见GitHub","categories":[{"name":"消息推送","slug":"消息推送","permalink":"https://yezihaohao.github.io/categories/消息推送/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://yezihaohao.github.io/tags/Nodejs/"},{"name":"Socket.io","slug":"Socket-io","permalink":"https://yezihaohao.github.io/tags/Socket-io/"}]},{"title":"Vuejs2.X组件化-阿里的G2图表组件","slug":"Vuejs2-X组件化-阿里的G2图表组件","date":"un22fin22","updated":"un22fin22","path":"2017/02/14/Vuejs2-X组件化-阿里的G2图表组件/","link":"","permalink":"https://yezihaohao.github.io/2017/02/14/Vuejs2-X组件化-阿里的G2图表组件/","excerpt":"前言 vue 的组件化开发是一个非常不错的机制.’一处开发,多处引用’，不仅降低的维护成本，提高了开发效率，而且单独的组件有单独的视图和交互数据逻辑，使得系统层次更加分明。若有问题可加群264591039与我讨论~转载文章请标明出处！ 开发场景数据可视化是我们互联网常见的功能，所以难免我们会在项目中插入图表等，找到一个还算可以的图形插件，阿里的G2图形库，详情请参见G2官网。接下来就开始我们的Vue G2组件化之旅。 脚手架搭建helloworld先用脚手架工具 vue-cli搭建一个vue的helloworld项目(Vue的相关教程请看Vue官网)，按照readme文档正常运行该项目。 安装G2插件在package.json的目录下用npm包管理工具安装G2插件库1npm install --save-dev g2 我用到的版本是2.2.1，现在最新的好像是2.2.2，应该也没什么问题，不过我没测试过 新建G2Line.vue单文件组件在components目录下新建G2Line.vue文件（当前是以线形图为例的组件）。在template标签中新增标签1234&lt;template&gt; &lt;!--此处的id用变量，方便同一页面引用多次相同的组件--&gt; &lt;div :id=\"id\"&gt;&lt;/div&gt;&lt;/template&gt;","text":"前言 vue 的组件化开发是一个非常不错的机制.’一处开发,多处引用’，不仅降低的维护成本，提高了开发效率，而且单独的组件有单独的视图和交互数据逻辑，使得系统层次更加分明。若有问题可加群264591039与我讨论~转载文章请标明出处！ 开发场景数据可视化是我们互联网常见的功能，所以难免我们会在项目中插入图表等，找到一个还算可以的图形插件，阿里的G2图形库，详情请参见G2官网。接下来就开始我们的Vue G2组件化之旅。 脚手架搭建helloworld先用脚手架工具 vue-cli搭建一个vue的helloworld项目(Vue的相关教程请看Vue官网)，按照readme文档正常运行该项目。 安装G2插件在package.json的目录下用npm包管理工具安装G2插件库1npm install --save-dev g2 我用到的版本是2.2.1，现在最新的好像是2.2.2，应该也没什么问题，不过我没测试过 新建G2Line.vue单文件组件在components目录下新建G2Line.vue文件（当前是以线形图为例的组件）。在template标签中新增标签1234&lt;template&gt; &lt;!--此处的id用变量，方便同一页面引用多次相同的组件--&gt; &lt;div :id=\"id\"&gt;&lt;/div&gt;&lt;/template&gt; 在script标签中引入G2并开始先关操作代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import G2 from 'g2'; export default &#123; data () &#123; return &#123; chart: null &#125;; &#125;, props: &#123; charData: &#123; type: Array, default: function () &#123; return &#123; data: [&#123;'mzkId': 112, 'strftime': \"2017-01-11\", 'value': 9275501&#125;, // 测试数据，根据自己需求自己设置数据 &#123;'mzkId': 112, 'strftime': \"2017-01-12\", 'value': 9281904&#125;, &#123;'mzkId': 112, 'strftime': \"2017-01-13\", 'value': 9290777&#125;, &#123;'mzkId': 112, 'strftime': \"2017-01-14\", 'value': 9297913&#125;, &#123;'mzkId': 112, 'strftime': \"2017-01-15\", 'value': 9306918&#125;, &#123;'mzkId': 112, 'strftime': \"2017-01-16\", 'value': 9315641&#125;] &#125;; &#125; &#125;, id: String &#125;, mounted: function () &#123;// this.drawChart(); // 第一步想到的是创建的时候更新图表，但是这个不适用于异步请求接口获取相关数据，所以采用下面的监听的方式 &#125;, beforeUpdate: function () &#123;// this.drawChart(); &#125;, watch: &#123; charData: function (val, oldVal) &#123; // 监听charData，当放生变化时，触发这个回调函数绘制图表 console.log('new: %s, old: %s', val, oldVal); this.drawChart(val); &#125; &#125;, methods: &#123; drawChart: function (datas) &#123; // 如果图形存在则删除再创建，这个地方感觉稍微有点坑 // 具体的G2 api函数说明请看上面提供的官网地址，此处不再逐一说明 this.chart &amp;&amp; this.chart.destroy(); let data = datas; this.chart = new G2.Chart(&#123; id: this.id, width: 1000, height: 250 &#125;); this.chart.source(data, &#123; strftime: &#123; alias: '日期', type: 'cat', range: [0, 1] &#125;, value: &#123; alias: '数量值(人)' &#125; &#125;); this.chart.line().position('strftime*value').size(2); this.chart.point().position('strftime*value').color('#757373') .shape('circle') .label('value', &#123;offset: 20, label: &#123;fill: '#000'&#125;&#125;); this.chart.animate(false); this.chart.render(); &#125; &#125; &#125; App.vue引入组件并渲染图表在app.vue中引入上一步新建的G2Line.vue组件，并加载到当前vue实例中1234567891011121314151617&lt;script&gt; import G2Line from './components/G2Line.vue'; export default &#123; components: &#123; G2Line &#125;, data () &#123; return &#123; serverData: [] &#125; &#125;, methods: &#123; // 此处省略从服务器获取数据并且赋值给this.serverData // 推荐使用axios请求接口 &#125; &#125;&lt;/script&gt; 获取服务端数据之后，在template中创建组件标签，并将serverData发送给子组件G2Line12&lt;!--同步设置id传送给子组件--&gt;&lt;g2-line :charData=\"serverData\" :id=\"'c1'\" id=\"c1\"&gt;&lt;/g2-line&gt; 刷新界面，成功看到页面图表的渲染","categories":[],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"https://yezihaohao.github.io/tags/Vuejs/"}]},{"title":"Nodejs爬虫--抓取豆瓣电影网页数据（下）","slug":"Nodejs爬虫-抓取豆瓣电影网页数据（下）","date":"un66fin66","updated":"un66fin66","path":"2017/02/11/Nodejs爬虫-抓取豆瓣电影网页数据（下）/","link":"","permalink":"https://yezihaohao.github.io/2017/02/11/Nodejs爬虫-抓取豆瓣电影网页数据（下）/","excerpt":"接着上篇 Nodejs爬虫–抓取豆瓣电影网页数据（上） 本篇主要描述将上次抓取的数据存入mongodb数据库 前提：百度或谷歌mongodb的安装教程，安装本地并成功运行 推荐一款mongodb数据库可视化管理工具：Robomongo。可以加群264591039获取安装包或自行寻找资源 首先用npm安装第三方数据库操作包：mongoose.关于mongoose详情请查看官方文档1npm install --save-dev mongoose 引入mongoose包开始对mongodb进行管理当前目录下新建一个mongo.js文件方便管理，在该文件中引入相关包：12let mongoose = require('mongoose'), assert = require('assert');","text":"接着上篇 Nodejs爬虫–抓取豆瓣电影网页数据（上） 本篇主要描述将上次抓取的数据存入mongodb数据库 前提：百度或谷歌mongodb的安装教程，安装本地并成功运行 推荐一款mongodb数据库可视化管理工具：Robomongo。可以加群264591039获取安装包或自行寻找资源 首先用npm安装第三方数据库操作包：mongoose.关于mongoose详情请查看官方文档1npm install --save-dev mongoose 引入mongoose包开始对mongodb进行管理当前目录下新建一个mongo.js文件方便管理，在该文件中引入相关包：12let mongoose = require('mongoose'), assert = require('assert'); 获取表构造器Schema并映射mongodb相应的collection12345678910111213let Schema = mongoose.Schema;let filmSchema = new Schema(&#123; //自定义相应的表数据字段 title: String, type: String, directories: String, scriptwriter: String, actors: String &#125;);//映射collection并生成model对象用于管理数据表的增删改查//默认是映射到名为films的collection//若自定义表明则：let filmSchema = new Schema(&#123;..&#125;, &#123; collection: 'data' &#125;); 'data'即为自定义名称let Film = mongoose.model('Film', filmSchema); 连接mongodb数据库并exports Film对象123456789let db = mongoose.connect('mongodb://127.0.0.1:27017/spider');db.connection.on('error', (err) =&gt; &#123; console.log(`数据库连接失败：$&#123;err&#125;`);&#125;);db.connection.on('open', () =&gt; &#123; console.log('数据库连接成功');&#125;);module.exports = &#123;Film: Film&#125;; 在spider.js中引入Film对象并添加入库操作代码123456789101112131415161718let mongo = require('./mongo');//在请求网页的end函数中添加入库操作xxxx.end((err, res) =&gt; &#123; var $ = cheerio.load(res.text); //用cheerio获取整个页面DOM对象 var _data = &#123;title:'', type: '', directories: '', scriptwriter: '', actors: ''&#125;; _data.title = $('#content h1 span').text(); _data.directories = $('#info .attrs').eq(0).text(); _data.scriptwriter = $('#info .attrs').eq(1).text(); _data.actors = $('#info .attrs').eq(2).text(); $('span[property=\"v:genre\"]').each(function (index) &#123; _data.type += ($(this).text() + (index == $('span[property=\"v:genre\"]').length - 1 ? '' : '、')); &#125;); console.log(_data); mongo.Film.create(_data, (err, doc) =&gt; &#123; assert.equal(err, null); console.log(doc); &#125;);&#125;); 运行spider.js，并查看数据库中的数据12node spider.js//用上述提到的可视化工具查看数据库是否成功有数据入库","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://yezihaohao.github.io/categories/爬虫/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yezihaohao.github.io/tags/Javascript/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://yezihaohao.github.io/tags/Nodejs/"}]},{"title":"Javascript正则表达式整合","slug":"Javascript正则表达式整合","date":"un55fin55","updated":"un55fin55","path":"2017/02/10/Javascript正则表达式整合/","link":"","permalink":"https://yezihaohao.github.io/2017/02/10/Javascript正则表达式整合/","excerpt":"项目中常用正则表达式使用整合大全提取网页标签内容一.单个标签提取123let str = `&lt;a class=\"menu\"&gt;GitHub&lt;/a&gt;`;let content = str.match(/&lt;a class=\"menu\"&gt;([\\s\\S]+)&lt;\\/a&gt;/)[1];","text":"项目中常用正则表达式使用整合大全提取网页标签内容一.单个标签提取123let str = `&lt;a class=\"menu\"&gt;GitHub&lt;/a&gt;`;let content = str.match(/&lt;a class=\"menu\"&gt;([\\s\\S]+)&lt;\\/a&gt;/)[1]; 不定时更新中…","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://yezihaohao.github.io/categories/正则表达式/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yezihaohao.github.io/tags/Javascript/"}]},{"title":"Nodejs爬虫--抓取豆瓣电影网页数据（上）","slug":"Nodejs爬虫-抓取豆瓣电影网页数据（上）","date":"un44fin44","updated":"un66fin66","path":"2017/02/09/Nodejs爬虫-抓取豆瓣电影网页数据（上）/","link":"","permalink":"https://yezihaohao.github.io/2017/02/09/Nodejs爬虫-抓取豆瓣电影网页数据（上）/","excerpt":"之前写了一个nodejs的开源爬虫小项目，补上博客详细解析下代码。 PS：共有上下两篇，第一篇讲从网站上抓取数据，第二篇讲将抓取的数据存入mongodb数据库。 我们快速开始吧首先，安装nodejs，然后用npm工具初始化资源管理配置文件：package.json新建spider文件夹，在该文件夹下面初始化package.json1npm init 然后用npm安装相关库文件：1npm install --save-dev superagent cheerio eventproxy async 在文件夹下面新建spider.js, 在文件中引入需要用到的nodejs模块如下(具体用法请查询网上相关资料)：12345let superagent = require('superagent'), //nodejs里面一个非常方便的客户端代理请求模块，支持get,post,put,delete等 cheerio = require('cheerio'), //类似于jQuery的DOM操作模块，可以提取html中想要的信息 eventproxy = require('eventproxy'), //控制异步请求并发，可以监听请求，使得某些请求完毕之后在发送请求 assert = require('assert'), //异常抛出判断模块，assert.equal(err, null); 如果err不为null,则直接抛出异常 async = require('async'); //控制请求并发连接数","text":"之前写了一个nodejs的开源爬虫小项目，补上博客详细解析下代码。 PS：共有上下两篇，第一篇讲从网站上抓取数据，第二篇讲将抓取的数据存入mongodb数据库。 我们快速开始吧首先，安装nodejs，然后用npm工具初始化资源管理配置文件：package.json新建spider文件夹，在该文件夹下面初始化package.json1npm init 然后用npm安装相关库文件：1npm install --save-dev superagent cheerio eventproxy async 在文件夹下面新建spider.js, 在文件中引入需要用到的nodejs模块如下(具体用法请查询网上相关资料)：12345let superagent = require('superagent'), //nodejs里面一个非常方便的客户端代理请求模块，支持get,post,put,delete等 cheerio = require('cheerio'), //类似于jQuery的DOM操作模块，可以提取html中想要的信息 eventproxy = require('eventproxy'), //控制异步请求并发，可以监听请求，使得某些请求完毕之后在发送请求 assert = require('assert'), //异常抛出判断模块，assert.equal(err, null); 如果err不为null,则直接抛出异常 async = require('async'); //控制请求并发连接数 用superagent请求豆瓣的某个接口，并把所有的页面链接放到一个数组里面，用eventproxy控制监听该请求结束之后才开始请求相应的详情页面。12345678superagent.get(URL) .end((err, res) =&gt; &#123; let _pageUrls = []; res.body.forEach((val) =&gt; &#123; _pageUrls.push(val.url); &#125;); ep.emit('pageUrls', _pageUrls); //监听相关实例，完成之后告诉pageUrls &#125;) 监听事件完成之后，执行请求相应的豆瓣电影详情页面.并用async控制请求的并发量，可以降低请求的频率和速度123456789101112131415161718192021222324252627let ep = eventproxy.create('pageUrls', (pageUrls) =&gt; &#123; //创建一个监听实例 let _http = (url, callback) =&gt; &#123; let _delay = parseInt((Math.random() * 30000000) % 1000, 10); //随机延时请求 superagent.get(url) .end((err, res) =&gt; &#123; var $ = cheerio.load(res.text); //用cheerio获取整个页面DOM对象 var _data = &#123;title:'', type: '', directories: '', scriptwriter: '', actors: ''&#125;; _data.title = $('#content h1 span').text(); _data.directories = $('#info .attrs').eq(0).text(); _data.scriptwriter = $('#info .attrs').eq(1).text(); _data.actors = $('#info .attrs').eq(2).text(); $('span[property=\"v:genre\"]').each(function (index) &#123; _data.type += ($(this).text() + (index == $('span[property=\"v:genre\"]').length - 1 ? '' : '、')); &#125;); console.log(_data); &#125;); setTimeout(() =&gt; &#123; callback(null, url); &#125;, _delay); &#125;; async.mapLimit(pageUrls, 3, (url, callback) =&gt; &#123; //用async 的 mapLimit(arr, limit, iterator, callback) 接口控制请求并发量为3 _http(url, callback); &#125;, (err, res) =&gt; &#123; assert.equal(err, null); &#125;)&#125;); 本章节结束，未完待续…下期是怎么将抓取的数据存入mongodb数据库！","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://yezihaohao.github.io/categories/爬虫/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://yezihaohao.github.io/tags/Javascript/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://yezihaohao.github.io/tags/Nodejs/"}]}]}